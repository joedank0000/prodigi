/**
 * beats.ts
 * ─────────────────────────────────────────────────────────────────────────────
 * Defines the Beat type and provides a loader that reads beat data from a
 * static JSON manifest at /beats/manifest.json.
 *
 * FOLDER STRUCTURE (inside public/beats/):
 * ─────────────────────────────────────────
 * public/
 *   beats/
 *     manifest.json          ← generated by the helper script below
 *     blood-money/
 *       audio.mp3
 *       info.txt
 *     golden-hour/
 *       audio.mp3
 *       info.txt
 *
 * info.txt FORMAT (one key per line, colon-separated):
 * ─────────────────────────────────────────────────────
 *   BPM: 140
 *   Key: F# Minor
 *   Price: 29.99
 *   Tags: Dark, Trap, Hard
 *
 * manifest.json FORMAT:
 * ─────────────────────
 *   [
 *     { "folder": "blood-money", "title": "Blood Money" },
 *     { "folder": "golden-hour", "title": "Golden Hour" }
 *   ]
 *
 * (The title field is optional — if omitted, the folder name is converted to
 *  title case and used as the beat title.)
 * ─────────────────────────────────────────────────────────────────────────────
 */

// ─── Types ────────────────────────────────────────────────────────────────────

export interface Beat {
  id: string;
  title: string;
  folder: string;
  audioUrl: string;
  bpm: number;
  key: string;
  price: number;
  tags: string[];
}

export interface ManifestEntry {
  folder: string;
  title?: string;
}

// ─── Helpers ──────────────────────────────────────────────────────────────────

/**
 * Converts a folder slug like "blood-money" → "Blood Money"
 */
function slugToTitle(slug: string): string {
  return slug
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
}

/**
 * Parse the raw text content of an info.txt file into structured metadata.
 * Lines that cannot be parsed are silently skipped.
 *
 * Example input:
 *   BPM: 140
 *   Key: F# Minor
 *   Price: 29.99
 *   Tags: Dark, Trap, Hard
 */
function parseInfoTxt(text: string): Partial<Omit<Beat, "id" | "title" | "folder" | "audioUrl">> {
  const result: Partial<Omit<Beat, "id" | "title" | "folder" | "audioUrl">> = {};

  for (const raw of text.split("\n")) {
    const line = raw.trim();
    if (!line) continue;

    const colonIdx = line.indexOf(":");
    if (colonIdx === -1) continue;

    const key = line.slice(0, colonIdx).trim().toLowerCase();
    const value = line.slice(colonIdx + 1).trim();

    switch (key) {
      case "bpm":
        result.bpm = parseInt(value, 10) || 0;
        break;
      case "key":
        result.key = value;
        break;
      case "price":
        result.price = parseFloat(value) || 0;
        break;
      case "tags":
        result.tags = value
          .split(",")
          .map((t) => t.trim())
          .filter(Boolean);
        break;
    }
  }

  return result;
}

// ─── Loader ───────────────────────────────────────────────────────────────────

/**
 * Fetches /beats/manifest.json, then for each entry fetches the matching
 * info.txt and assembles Beat objects.
 *
 * Returns an empty array (never throws) so the app can fall back to demo data.
 */
export async function loadBeatsFromManifest(): Promise<Beat[]> {
  // 1. Fetch the manifest
  let entries: ManifestEntry[];
  try {
    const res = await fetch("/beats/manifest.json");
    if (!res.ok) return [];
    entries = (await res.json()) as ManifestEntry[];
  } catch {
    return [];
  }

  if (!Array.isArray(entries) || entries.length === 0) return [];

  // 2. For each entry, fetch info.txt concurrently
  const beats = await Promise.all(
    entries.map(async (entry, idx): Promise<Beat | null> => {
      const { folder } = entry;
      if (!folder) return null;

      const infoUrl = `/beats/${folder}/info.txt`;
      let meta: Partial<Omit<Beat, "id" | "title" | "folder" | "audioUrl">> = {};

      try {
        const infoRes = await fetch(infoUrl);
        if (infoRes.ok) {
          const txt = await infoRes.text();
          meta = parseInfoTxt(txt);
        }
      } catch {
        // info.txt not found — continue with defaults
      }

      return {
        id: `beat-${idx + 1}`,
        title: entry.title ?? slugToTitle(folder),
        folder,
        audioUrl: `/beats/${folder}/audio.mp3`,
        bpm: meta.bpm ?? 0,
        key: meta.key ?? "Unknown",
        price: meta.price ?? 0,
        tags: meta.tags ?? [],
      };
    })
  );

  return beats.filter((b): b is Beat => b !== null);
}
